
all: lpp

# DEFINITIONS

cmo = @cmo@
cma = @cma@
OCAMLC = @OCAMLC@ -c -I ndcore
OCAMLL = @OCAMLC@
OCAMLDEP = @OCAMLDEP@ -I ndcore
OCAMLDOC = ocamldoc
OCAMLYACC = @OCAMLYACC@ -v
OCAMLLEX = @OCAMLLEX@

# SOURCE FILES

CORE_ML    = ndcore/term.ml ndcore/norm.ml ndcore/pprint.ml ndcore/unify.ml \
             ndcore/index.ml
TEST_ML    = ext/oUnit.ml ndcore/test.ml
LPP_ML  = table.ml system.ml parser.ml lexer.ml prover.ml main.ml

CORE_SRC   = $(CORE_ML) $(wildcard $(CORE_ML:.ml=.mli))
LPP_SRC = $(LPP_ML) $(wildcard $(LPP_ML:.ml=.mli))

LPP = $(CORE_ML:.ml=.$(cmo)) $(LPP_ML:.ml=.$(cmo))
TEST = $(CORE_ML:.ml=.$(cmo)) $(TEST_ML:.ml=.$(cmo))

# BUILDING

lpp: $(LPP)
	$(OCAMLL) unix.$(cma) $(LPP) -o lpp

-include depend
depend: $(CORE_SRC) $(LPP_SRC) $(TEST_ML)
	$(OCAMLDEP) $(CORE_SRC) $(LPP_SRC) $(TEST_ML) > depend

%.cmx: %.ml
	$(OCAMLC) $<
%.cmo: %.ml
	$(OCAMLC) $<
%.cmi: %.mli
	$(OCAMLC) $<
%.ml: %.mly Makefile
	$(OCAMLYACC) $<
	echo $<
	echo "val to_term : (Lexing.lexbuf -> token) -> string -> Term.term" \
	  >> $(<:.mly=.mli)
%.mli: %.mly Makefile
	$(OCAMLYACC) $<
	echo "val to_term : (Lexing.lexbuf -> token) -> string -> Term.term" \
	  >> $(<:.mly=.mli)
%.ml: %.mll
	$(OCAMLLEX) $<

# TARGETS FOR CORE LLAMBDA MODULES

test: ndcore/test
	ndcore/test
ndcore/test: $(TEST)
	$(OCAMLL) unix.$(cma) $(TEST) -o ndcore/test

# MISC

run: lpp
	ledit ./lpp

.PHONY: clean
clean:
	rm -f lpp
	rm -f ndcore/test
	rm -f parser.ml parser.mli lexer.ml parser.output
	rm -f *.cm[ixo] *.o
	rm -f ndcore/*.cm[ixo] ndcore/*.o

.PHONY: superclean
superclean: clean
	find . -name '*~' -exec rm \{\} \;
	rm -f depend
	rm -f ndcore/depend
